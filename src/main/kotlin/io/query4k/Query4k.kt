package io.query4k

import arrow.core.Either
import arrow.core.flatten
import arrow.core.raise.either
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.json.Json
import kotlinx.serialization.serializer
import org.jdbi.v3.core.Handle
import org.jdbi.v3.core.Jdbi
import org.jdbi.v3.core.result.ResultIterable
import java.sql.SQLException
import javax.sql.DataSource
import kotlin.jvm.optionals.getOrNull

class Query4k private constructor(private val jdbi: Jdbi) {
    companion object {
        /** Create an instance from a JDBI instance. */
        @Suppress("unused")
        fun create(jdbi: Jdbi): Query4k = Query4k(jdbi)

        /** Create an instance from a data source, such as a Hikari CP data source. */
        @Suppress("unused")

        fun create(dataSource: DataSource): Query4k = Query4k(Jdbi.create(dataSource))

        /** Create an instance from a URL. */
        @Suppress("unused")
        fun create(
            url: String,
            username: String? = null,
            password: String? = null
        ): Query4k = Query4k(
            if (username == null && password == null)
                Jdbi.create(url)
            else
                Jdbi.create(url, username, password)
        )
    }

    /**  */
    private suspend fun execute(
        handle: Handle, sql: String,
        params: Map<String, Any>?
    ): Either<SQLException, Int> = Either.catchOrThrow<SQLException, Int> {
        withContext(Dispatchers.IO) {
            handle.createUpdate(sql)
                .bindMap(params)
                .execute()
        }
    }

    /** Executes, and retrieves auto-generated keys */
    private suspend fun executeAndReturnAutoGeneratedKeys(
        handle: Handle, sql: String, params: Map<String, Any>?
    ) = Either.catchOrThrow<SQLException, List<Map<String, Any>>> {
        withContext(Dispatchers.IO) {
            handle.createUpdate(sql)
                .bindMap(params)
                .executeAndReturnGeneratedKeys()
                .mapToMap()
                .list()
        }
    }

    /** Executes a single SQL statement.
     * Example use:
     *
     * ```
     *q4k.execute(
     *   "UPDATE users SET email=:email WHERE id=:id",
     *   mapOf("id" to 0, "email" to "example@email.com")
     *)
     * ```
     *
     * @return Number of affected rows */
    suspend fun execute(
        sql: String,
        params: Map<String, Any>? = null
    ): Either<SQLException, Int> = either {
        handle().use {
            execute(it, sql, params).bind()
        }
    }

    suspend fun executeAndReturnAutoGeneratedKeys(
        sql: String,
        params: Map<String, Any>? = null
    ): Either<SQLException, List<Map<String, Any>>> = either {
        handle().use {
            executeAndReturnAutoGeneratedKeys(it, sql, params).bind()
        }
    }

    suspend fun query(
        handle: Handle,
        sql: String,
        params: Map<String, Any>? = null
    ): Either<SQLException, List<Map<String, Any>>> = Either.catchOrThrow {
        withContext(Dispatchers.IO) {
            handle.createQuery(sql)
                .bindMap(params)
                .mapToMap().list()
        }
    }

    suspend fun queryFirst(
        handle: Handle,
        sql: String,
        params: Map<String, Any>?
    ): Either<SQLException, Map<String, Any>?> = Either.catchOrThrow {
        withContext(Dispatchers.IO) {
            handle.createQuery(sql)
                .bindMap(params)
                .mapToMap()
                .findFirst()
        }.getOrNull()
    }

    private fun ResultIterable<Map<String, Any>>.safeFindOnly() = Either.catchOrThrow<IllegalStateException, Map<String, Any>> {
        this.findOnly()
    }.mapLeft { QueryOnlyError.IllegalStateError }

    suspend fun queryOnly(
        handle: Handle,
        sql: String,
        params: Map<String, Any>?
    ): Either<QueryOnlyError, Map<String, Any>> = Either.catchOrThrow<SQLException, Either<QueryOnlyError.IllegalStateError, Map<String, Any>>> {
        withContext(Dispatchers.IO) {
            handle.createQuery(sql)
                .bindMap(params)
                .mapToMap()
                .safeFindOnly()
        }
    }.mapLeft {
        QueryOnlyError.ConnectionError
    }.flatten()

    suspend inline fun <reified A> query(
        sql: String,
        params: Map<String, Any>? = null
    ): Either<SQLException, List<A>> = either {
        handle().use { handle ->
            val results = query(handle, sql, params).bind()
            results.map { row -> row.mapValues { it.value.toJsonElement() } }
                .map { Json.encodeToString(serializer(), it) }
                .map { Json.decodeFromString<A>(it) }
        }
    }

    suspend inline fun <reified A> queryFirst(
        sql: String,
        params: Map<String, Any>? = null
    ): Either<SQLException, A?> = either {
        handle().use { handle ->
            queryFirst(handle, sql, params).bind()
                ?.mapValues { it.value.toJsonElement() }
                ?.let { Json.encodeToString(serializer(), it) }
                ?.let { Json.decodeFromString<A>(it) }
        }
    }

    suspend inline fun <reified A> queryOnly(
        sql: String,
        params: Map<String, Any>? = null
    ): Either<QueryOnlyError, A> = either {
        handle().use {  handle ->
            queryOnly(handle, sql, params)
                .bind()
                .mapValues { it.value.toJsonElement() }
                .let { Json.encodeToString(serializer(), it) }
                .let { Json.decodeFromString<A>(it) }
        }
    }

    fun handle(): Handle = jdbi.open()
}
